<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>🎵 Music Search + Play</title>
  <style>
    /* --- your CSS is unchanged --- */
  </style>
</head>
<body>
  <!-- --- your HTML body is unchanged --- -->

  <script>
    // Replace with your YouTube API key
    const YOUTUBE_API_KEY = "AIzaSyBcGIEyPh4g7TN2gV4CN_KAcO4SpjGJCFA";
    
    // DOM elements
    const queryInput = document.getElementById('query');
    const statusBox = document.getElementById('status');
    const resultsEl = document.getElementById('results');
    const playerEl = document.getElementById('player');
    const playerImg = document.getElementById('player-img');
    const playerTitle = document.getElementById('player-title');
    const playerArtist = document.getElementById('player-artist');
    const playBtn = document.getElementById('play-btn');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const shuffleBtn = document.getElementById('shuffle-btn');
    const repeatBtn = document.getElementById('repeat-btn');
    const volumeBtn = document.getElementById('volume-btn');
    const currentTimeEl = document.getElementById('current-time');
    const durationEl = document.getElementById('duration');
    const progressBar = document.getElementById('progress-bar');
    const progress = document.getElementById('progress');
    const progressHandle = document.getElementById('progress-handle');
    
    // Player state
    let player;
    let currentTrack = null;
    let isPlaying = false;
    let isShuffled = false;
    let isRepeated = false;
    let updateInterval;
    let searchResults = [];
    let currentTrackIndex = -1;
    
    // Initialize YouTube Player
    function initYouTubePlayer() {
      const tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      const firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }
    
    function onYouTubeIframeAPIReady() {
      player = new YT.Player('yt-frame', {
        events: {
          'onReady': onPlayerReady,
          'onStateChange': onPlayerStateChange
        }
      });
    }
    
    function onPlayerReady(event) {
      document.querySelectorAll('.player-button').forEach(btn => {
        btn.disabled = false;
      });
    }
    
    function onPlayerStateChange(event) {
      switch(event.data) {
        case YT.PlayerState.PLAYING:
          isPlaying = true;
          updatePlayButton();
          startProgressTimer();
          break;
        case YT.PlayerState.PAUSED:
          isPlaying = false;
          updatePlayButton();
          clearInterval(updateInterval);
          break;
        case YT.PlayerState.ENDED:
          isPlaying = false;
          updatePlayButton();
          clearInterval(updateInterval);
          if (isRepeated) {
            player.seekTo(0);
            player.playVideo();
          } else {
            playNextTrack();
          }
          break;
      }
    }
    
    // Search input
    let searchTimeout;
    queryInput.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      const q = e.target.value.trim();
      if (!q) {
        resultsEl.innerHTML = '';
        statusBox.textContent = '';
        return;
      }
      statusBox.textContent = 'Searching...';
      searchTimeout = setTimeout(() => searchMusic(q), 500);
    });
    
    async function searchMusic(q) {
      try {
        const url = `https://musicbrainz.org/ws/2/recording?query=${encodeURIComponent(q)}&fmt=json&limit=12&inc=releases+artist-credits`;
        const res = await fetch(url, { 
          headers: { 'User-Agent': 'music-search-spotify/1.0 (example@example.com)' } 
        });
        const data = await res.json();
        searchResults = Array.isArray(data.recordings) ? data.recordings : [];
        if (searchResults.length === 0) {
          statusBox.textContent = 'No results found. Try a different search.';
          resultsEl.innerHTML = '';
          return;
        }
        statusBox.textContent = '';
        renderResults(searchResults);
      } catch (err) {
        console.error(err);
        statusBox.textContent = 'Failed to search. Check your network.';
      }
    }
    
    function renderResults(items) {
      resultsEl.innerHTML = '';
      items.forEach((rec, index) => {
        const card = document.createElement('div');
        card.className = 'card';
        const img = document.createElement('img');
        img.className = 'card-img';
        const releaseId = rec.releases?.[0]?.id;
        if (releaseId) {
          img.src = `https://coverartarchive.org/release/${releaseId}/front-250`;
          img.onerror = () => { img.src = placeholder(); };
        } else {
          img.src = placeholder();
        }
        const title = document.createElement('div');
        title.className = 'card-title';
        title.textContent = rec.title || 'Untitled';
        const subtitle = document.createElement('div');
        subtitle.className = 'card-subtitle';
        const artists = rec['artist-credit']?.map(a => a.name).join(', ') || 'Unknown artist';
        const releaseDate = rec['first-release-date'] || 'Unknown year';
        subtitle.textContent = `${artists} • ${releaseDate}`;
        const playBtn = document.createElement('div');
        playBtn.className = 'card-play';
        playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M4.018 14L14.41 8 4.018 2z"></path></svg>';
        playBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          playTrack(index);
        });
        card.appendChild(img);
        card.appendChild(title);
        card.appendChild(subtitle);
        card.appendChild(playBtn);
        card.addEventListener('click', () => playTrack(index));
        resultsEl.appendChild(card);
      });
    }
    
    async function playTrack(index) {
      if (!searchResults[index]) return;
      const rec = searchResults[index];
      const artists = rec['artist-credit']?.map(a => a.name).join(', ') || 'Unknown artist';
      const imgUrl = rec.releases?.[0]?.id 
        ? `https://coverartarchive.org/release/${rec.releases[0].id}/front-250` 
        : placeholder();
      currentTrackIndex = index;
      currentTrack = { title: rec.title || 'Untitled', artist: artists, imgUrl };
      playerTitle.textContent = currentTrack.title;
      playerArtist.textContent = currentTrack.artist;
      playerImg.src = currentTrack.imgUrl;
      playerEl.style.display = 'grid';
      try {
        const q = `${currentTrack.title} ${currentTrack.artist}`.trim();
        const videoId = await searchYouTubeVideo(q);
        if (!videoId) {
          alert('No YouTube video found for this track');
          return;
        }
        if (player && typeof player.loadVideoById === 'function') {
          player.loadVideoById(videoId);
          player.playVideo();
        } else {
          document.getElementById('yt-frame').src = `https://www.youtube.com/embed/${videoId}?autoplay=1&enablejsapi=1`;
        }
      } catch (err) {
        console.error('Error playing track:', err);
        alert('Failed to load video');
      }
    }
    
    async function searchYouTubeVideo(q) {
      const endpoint = new URL('https://www.googleapis.com/youtube/v3/search');
      endpoint.searchParams.set('part', 'snippet');
      endpoint.searchParams.set('type', 'video');
      endpoint.searchParams.set('maxResults', '1');
      endpoint.searchParams.set('q', q);
      endpoint.searchParams.set('key', YOUTUBE_API_KEY);
      const res = await fetch(endpoint.toString());
      const data = await res.json();
      return data.items?.[0]?.id?.videoId || null;
    }
    
    function togglePlay() {
      if (!player) return;
      if (isPlaying) player.pauseVideo();
      else player.playVideo();
    }
    function playNextTrack() {
      if (searchResults.length === 0) return;
      let nextIndex = isShuffled
        ? Math.floor(Math.random() * searchResults.length)
        : (currentTrackIndex + 1) % searchResults.length;
      playTrack(nextIndex);
    }
    function playPrevTrack() {
      if (searchResults.length === 0) return;
      let prevIndex = isShuffled
        ? Math.floor(Math.random() * searchResults.length)
        : (currentTrackIndex - 1 + searchResults.length) % searchResults.length;
      playTrack(prevIndex);
    }
    function toggleShuffle() {
      isShuffled = !isShuffled;
      shuffleBtn.classList.toggle('active', isShuffled);
    }
    function toggleRepeat() {
      isRepeated = !isRepeated;
      repeatBtn.classList.toggle('active', isRepeated);
    }
    function updatePlayButton() {
      if (isPlaying) {
        playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M3 3h3v10H3zm7 0h3v10h-3z"></path></svg>';
      } else {
        playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M4.018 14L14.41 8 4.018 2z"></path></svg>';
      }
    }
    function startProgressTimer() {
      clearInterval(updateInterval);
      updateProgress();
      updateInterval = setInterval(updateProgress, 1000);
    }
    function updateProgress() {
      if (!player) return;
      const currentTime = player.getCurrentTime();
      const duration = player.getDuration();
      if (duration && currentTime != null) {
        const progressPercent = (currentTime / duration) * 100;
        progress.style.width = `${progressPercent}%`;
        progressHandle.style.left = `${progressPercent}%`;
        currentTimeEl.textContent = formatTime(currentTime);
        durationEl.textContent = formatTime(duration);
      }
    }
    function seekToPosition(e) {
      if (!player) return;
      const rect = progressBar.getBoundingClientRect();
      const pos = Math.min(Math.max(0, (e.clientX - rect.left) / rect.width), 1);
      player.seekTo(player.getDuration() * pos);
    }
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
    }
    
    // Event listeners
    playBtn.addEventListener('click', togglePlay);
    prevBtn.addEventListener('click', playPrevTrack);
    nextBtn.addEventListener('click', playNextTrack);
    shuffleBtn.addEventListener('click', toggleShuffle);
    repeatBtn.addEventListener('click', toggleRepeat);
    progressBar.addEventListener('click', seekToPosition);

    // ❌ deleted old progressBar mousemove preview here

    // ✅ NEW draggable progress bar
    let isDragging = false;
    progressHandle.addEventListener('mousedown', (e) => {
      isDragging = true;
      updateSeek(e);
    });
    document.addEventListener('mousemove', (e) => {
      if (isDragging) updateSeek(e);
    });
    document.addEventListener('mouseup', (e) => {
      if (isDragging) {
        isDragging = false;
        seekToPosition(e);
      }
    });
    function updateSeek(e) {
      const rect = progressBar.getBoundingClientRect();
      const pos = Math.min(Math.max(0, (e.clientX - rect.left) / rect.width), 1);
      progress.style.width = `${pos * 100}%`;
      progressHandle.style.left = `${pos * 100}%`;
      const previewTime = player.getDuration() * pos;
      currentTimeEl.textContent = formatTime(previewTime);
    }

    // Disable buttons until player is ready
    document.querySelectorAll('.player-button').forEach(btn => btn.disabled = true);
    function placeholder() {
      return 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
    }
    initYouTubePlayer();
  </script>
</body>
</html>
